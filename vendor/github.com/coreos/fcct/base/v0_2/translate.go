// Copyright 2019 Red Hat, Inc
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.)

package v0_2

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"errors"
	"io/ioutil"
	"net/url"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"github.com/coreos/fcct/base"
	"github.com/coreos/fcct/translate"

	"github.com/coreos/go-systemd/unit"
	"github.com/coreos/ignition/v2/config/util"
	"github.com/coreos/ignition/v2/config/v3_1/types"
	"github.com/coreos/vcontext/path"
	"github.com/coreos/vcontext/report"
	"github.com/vincent-petithory/dataurl"
)

var (
	ErrFilesDirEscape   = errors.New("local file path traverses outside the files directory")
	ErrFileType         = errors.New("trees may only contain files, directories, and symlinks")
	ErrNodeExists       = errors.New("matching filesystem node has existing contents or different type")
	ErrNoFilesDir       = errors.New("local file paths are relative to a files directory that must be specified with -d/--files-dir")
	ErrTreeNotDirectory = errors.New("root of tree must be a directory")

	mountUnitTemplate = template.Must(template.New("unit").Parse(`# Generated by FCCT
[Unit]
Before=local-fs.target
Requires=systemd-fsck@{{.Device}}
After=systemd-fsck@{{.Device}}

[Mount]
Where={{.Path}}
What={{.Device}}
Type={{.Format}}
{{- if .MountOptions }}
Options=
  {{- range $i, $opt := .MountOptions }}
    {{- if $i }},{{ end }}
    {{- $opt }}
  {{- end }}
{{- end }}

[Install]
RequiredBy=local-fs.target`))
)

// ToIgn3_1 translates the config to an Ignition config. It also returns the set of translations
// it did so paths in the resultant config can be tracked back to their source in the source config.
func (c Config) ToIgn3_1(options base.TranslateOptions) (types.Config, translate.TranslationSet, report.Report) {
	ret := types.Config{}
	tr := translate.NewTranslator("yaml", "json", options)
	tr.AddCustomTranslator(translateIgnition)
	tr.AddCustomTranslator(translateFile)
	tr.AddCustomTranslator(translateDirectory)
	tr.AddCustomTranslator(translateLink)
	translations, report := tr.Translate(&c, &ret)
	translations.Merge(c.addMountUnits(&ret))

	ts, r := c.processTrees(&ret, options)
	translations.Merge(ts)
	report.Merge(r)

	return ret, translations, report
}

func translateIgnition(from Ignition, options base.TranslateOptions) (to types.Ignition, tm translate.TranslationSet, r report.Report) {
	tr := translate.NewTranslator("yaml", "json", options)
	tr.AddCustomTranslator(translateResource)
	to.Version = types.MaxVersion.String()
	tm, r = translate.Prefixed(tr, "config", &from.Config, &to.Config)
	translate.MergeP(tr, tm, &r, "proxy", &from.Proxy, &to.Proxy)
	translate.MergeP(tr, tm, &r, "security", &from.Security, &to.Security)
	translate.MergeP(tr, tm, &r, "timeouts", &from.Timeouts, &to.Timeouts)
	return
}

func translateFile(from File, options base.TranslateOptions) (to types.File, tm translate.TranslationSet, r report.Report) {
	tr := translate.NewTranslator("yaml", "json", options)
	tr.AddCustomTranslator(translateResource)
	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
	translate.MergeP(tr, tm, &r, "append", &from.Append, &to.Append)
	translate.MergeP(tr, tm, &r, "contents", &from.Contents, &to.Contents)
	to.Overwrite = from.Overwrite
	to.Path = from.Path
	to.Mode = from.Mode
	tm.AddIdentity("overwrite", "path", "mode")
	return
}

func translateResource(from Resource, options base.TranslateOptions) (to types.Resource, tm translate.TranslationSet, r report.Report) {
	tr := translate.NewTranslator("yaml", "json", options)
	tm, r = translate.Prefixed(tr, "verification", &from.Verification, &to.Verification)
	translate.MergeP(tr, tm, &r, "httpHeaders", &from.HTTPHeaders, &to.HTTPHeaders)
	to.Source = from.Source
	to.Compression = from.Compression
	tm.AddIdentity("source", "compression")

	if from.Local != nil {
		c := path.New("yaml", "local")

		if options.FilesDir == "" {
			r.AddOnError(c, ErrNoFilesDir)
			return
		}

		// calculate file path within FilesDir and check for
		// path traversal
		filePath := filepath.Join(options.FilesDir, *from.Local)
		if err := ensurePathWithinFilesDir(filePath, options.FilesDir); err != nil {
			r.AddOnError(c, err)
			return
		}

		contents, err := ioutil.ReadFile(filePath)
		if err != nil {
			r.AddOnError(c, err)
			return
		}

		src, gzipped, err := makeDataURL(contents, to.Compression)
		if err != nil {
			r.AddOnError(c, err)
			return
		}
		to.Source = &src
		tm.AddTranslation(c, path.New("json", "source"))
		if gzipped {
			to.Compression = util.StrToPtr("gzip")
			tm.AddTranslation(c, path.New("json", "compression"))
		}
	}

	if from.Inline != nil {
		c := path.New("yaml", "inline")

		src, gzipped, err := makeDataURL([]byte(*from.Inline), to.Compression)
		if err != nil {
			r.AddOnError(c, err)
			return
		}
		to.Source = &src
		tm.AddTranslation(c, path.New("json", "source"))
		if gzipped {
			to.Compression = util.StrToPtr("gzip")
			tm.AddTranslation(c, path.New("json", "compression"))
		}
	}
	return
}

func makeDataURL(contents []byte, currentCompression *string) (uri string, gzipped bool, err error) {
	// try three different encodings, and select the smallest one

	// URL-escaped, useful for ASCII text
	opaque := "," + dataurl.Escape(contents)

	// Base64-encoded, useful for small or incompressible binary data
	b64 := ";base64," + base64.StdEncoding.EncodeToString(contents)
	if len(b64) < len(opaque) {
		opaque = b64
	}

	// Base64-encoded gzipped, useful for compressible data.  If the
	// user already enabled compression, don't compress again.
	// We don't try base64-encoded URL-escaped because gzipped data is
	// binary and URL escaping is unlikely to be efficient.
	if currentCompression == nil || *currentCompression == "" {
		var buf bytes.Buffer
		var compressor *gzip.Writer
		if compressor, err = gzip.NewWriterLevel(&buf, gzip.BestCompression); err != nil {
			return
		}
		if _, err = compressor.Write(contents); err != nil {
			return
		}
		if err = compressor.Close(); err != nil {
			return
		}
		gz := ";base64," + base64.StdEncoding.EncodeToString(buf.Bytes())
		// Account for space needed by "compression": "gzip".
		if len(gz)+25 < len(opaque) {
			opaque = gz
			gzipped = true
		}
	}

	uri = (&url.URL{
		Scheme: "data",
		Opaque: opaque,
	}).String()
	return
}

func translateDirectory(from Directory, options base.TranslateOptions) (to types.Directory, tm translate.TranslationSet, r report.Report) {
	tr := translate.NewTranslator("yaml", "json", options)
	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
	to.Overwrite = from.Overwrite
	to.Path = from.Path
	to.Mode = from.Mode
	tm.AddIdentity("overwrite", "path", "mode")
	return
}

func translateLink(from Link, options base.TranslateOptions) (to types.Link, tm translate.TranslationSet, r report.Report) {
	tr := translate.NewTranslator("yaml", "json", options)
	tm, r = translate.Prefixed(tr, "group", &from.Group, &to.Group)
	translate.MergeP(tr, tm, &r, "user", &from.User, &to.User)
	to.Target = from.Target
	to.Hard = from.Hard
	to.Overwrite = from.Overwrite
	to.Path = from.Path
	tm.AddIdentity("target", "hard", "overwrite", "path")
	return
}

func (c Config) processTrees(ret *types.Config, options base.TranslateOptions) (translate.TranslationSet, report.Report) {
	ts := translate.NewTranslationSet("yaml", "json")
	var r report.Report
	if len(c.Storage.Trees) == 0 {
		return ts, r
	}
	t := newNodeTracker(ret)

	for i, tree := range c.Storage.Trees {
		yamlPath := path.New("yaml", "storage", "trees", i)
		if options.FilesDir == "" {
			r.AddOnError(yamlPath, ErrNoFilesDir)
			return ts, r
		}

		// calculate base path within FilesDir and check for
		// path traversal
		srcBaseDir := filepath.Join(options.FilesDir, tree.Local)
		if err := ensurePathWithinFilesDir(srcBaseDir, options.FilesDir); err != nil {
			r.AddOnError(yamlPath, err)
			continue
		}
		info, err := os.Stat(srcBaseDir)
		if err != nil {
			r.AddOnError(yamlPath, err)
			continue
		}
		if !info.IsDir() {
			r.AddOnError(yamlPath, ErrTreeNotDirectory)
			continue
		}
		destBaseDir := "/"
		if tree.Path != nil && *tree.Path != "" {
			destBaseDir = *tree.Path
		}

		walkTree(yamlPath, tree, &ts, &r, t, srcBaseDir, destBaseDir, options)
	}
	return ts, r
}

func walkTree(yamlPath path.ContextPath, tree Tree, ts *translate.TranslationSet, r *report.Report, t *nodeTracker, srcBaseDir, destBaseDir string, options base.TranslateOptions) {
	// The strategy for errors within WalkFunc is to add an error to
	// the report and return nil, so walking continues but translation
	// will fail afterward.
	err := filepath.Walk(srcBaseDir, func(srcPath string, info os.FileInfo, err error) error {
		if err != nil {
			r.AddOnError(yamlPath, err)
			return nil
		}
		relPath, err := filepath.Rel(srcBaseDir, srcPath)
		if err != nil {
			r.AddOnError(yamlPath, err)
			return nil
		}
		destPath := filepath.Join(destBaseDir, relPath)

		if info.Mode().IsDir() {
			return nil
		} else if info.Mode().IsRegular() {
			i, file := t.GetFile(destPath)
			if file != nil {
				if file.Contents.Source != nil && *file.Contents.Source != "" {
					r.AddOnError(yamlPath, ErrNodeExists)
					return nil
				}
			} else {
				if t.Exists(destPath) {
					r.AddOnError(yamlPath, ErrNodeExists)
					return nil
				}
				i, file = t.AddFile(types.File{
					Node: types.Node{
						Path: destPath,
					},
				})
				ts.AddFromCommonSource(yamlPath, path.New("json", "storage", "files", i), file)
			}
			contents, err := ioutil.ReadFile(srcPath)
			if err != nil {
				r.AddOnError(yamlPath, err)
				return nil
			}
			url, gzipped, err := makeDataURL(contents, file.Contents.Compression)
			if err != nil {
				r.AddOnError(yamlPath, err)
				return nil
			}
			file.Contents.Source = util.StrToPtr(url)
			ts.AddTranslation(yamlPath, path.New("json", "storage", "files", i, "contents", "source"))
			if gzipped {
				file.Contents.Compression = util.StrToPtr("gzip")
				ts.AddTranslation(yamlPath, path.New("json", "storage", "files", i, "contents", "compression"))
			}
			if file.Mode == nil {
				mode := 0644
				if info.Mode()&0111 != 0 {
					mode = 0755
				}
				file.Mode = &mode
				ts.AddTranslation(yamlPath, path.New("json", "storage", "files", i, "mode"))
			}
		} else if info.Mode()&os.ModeType == os.ModeSymlink {
			i, link := t.GetLink(destPath)
			if link != nil {
				if link.Target != "" {
					r.AddOnError(yamlPath, ErrNodeExists)
					return nil
				}
			} else {
				if t.Exists(destPath) {
					r.AddOnError(yamlPath, ErrNodeExists)
					return nil
				}
				i, link = t.AddLink(types.Link{
					Node: types.Node{
						Path: destPath,
					},
				})
				ts.AddFromCommonSource(yamlPath, path.New("json", "storage", "links", i), link)
			}
			link.Target, err = os.Readlink(srcPath)
			if err != nil {
				r.AddOnError(yamlPath, err)
				return nil
			}
			ts.AddTranslation(yamlPath, path.New("json", "storage", "links", i, "target"))
		} else {
			r.AddOnError(yamlPath, ErrFileType)
			return nil
		}
		return nil
	})
	r.AddOnError(yamlPath, err)
}

func (c Config) addMountUnits(ret *types.Config) translate.TranslationSet {
	ts := translate.NewTranslationSet("yaml", "json")
	if len(c.Storage.Filesystems) == 0 {
		return ts
	}
	unitMap := make(map[string]int, len(ret.Systemd.Units))
	for i, u := range ret.Systemd.Units {
		unitMap[u.Name] = i
	}
	for i, fs := range c.Storage.Filesystems {
		if fs.WithMountUnit == nil || !*fs.WithMountUnit {
			continue
		}
		fromPath := path.New("yaml", "storage", "filesystems", i, "with_mount_unit")
		newUnit := mountUnitFromFS(fs)
		if i, ok := unitMap[unit.UnitNamePathEscape(*fs.Path)+".mount"]; ok {
			// user also specified a unit, only set contents and enabled if the existing unit
			// is unspecified
			u := &ret.Systemd.Units[i]
			unitPath := path.New("json", "systemd", "units", i)
			if u.Contents == nil {
				(*u).Contents = newUnit.Contents
				ts.AddTranslation(fromPath, unitPath.Append("contents"))
			}
			if u.Enabled == nil {
				(*u).Enabled = newUnit.Enabled
				ts.AddTranslation(fromPath, unitPath.Append("enabled"))
			}
		} else {
			unitPath := path.New("json", "systemd", "units", len(ret.Systemd.Units))
			ret.Systemd.Units = append(ret.Systemd.Units, newUnit)
			ts.AddFromCommonSource(fromPath, unitPath, newUnit)
		}
	}
	return ts
}

func mountUnitFromFS(fs Filesystem) types.Unit {
	contents := strings.Builder{}
	err := mountUnitTemplate.Execute(&contents, fs)
	if err != nil {
		panic(err)
	}
	// unchecked deref of path ok, fs would fail validation otherwise
	unitName := unit.UnitNamePathEscape(*fs.Path) + ".mount"
	return types.Unit{
		Name:     unitName,
		Enabled:  util.BoolToPtr(true),
		Contents: util.StrToPtr(contents.String()),
	}
}

func ensurePathWithinFilesDir(path, filesDir string) error {
	absBase, err := filepath.Abs(filesDir)
	if err != nil {
		return err
	}
	absPath, err := filepath.Abs(path)
	if err != nil {
		return err
	}
	if !strings.HasPrefix(absPath, absBase+string(filepath.Separator)) {
		return ErrFilesDirEscape
	}
	return nil
}
